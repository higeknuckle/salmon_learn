<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>YouTube専用2窓実況支援ツール</title>
<script type="text/javascript" src="../tyrano/libs/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="youtube-iframe-api.js"></script>
<script type="text/javascript" src="sound.js"></script>
<script>
/*
function get_api_script () {
	$.ajax({
		url: 'http://www.youtube.com/player_api/',
		dataType: 'script',
		success: function (data) {
			console.log('youtube iframe api is ready!');
		},
		error: function (xhr, status, thrown) {
			console.log(xhr);
		}
	}); 
}
get_api_script();
*/
// window.onYouTubeIframeAPIReady = function () {
window.sound = new Sound();
window.onload = function () {
	window.storage_key = 'youtube_2_mado';
	window.g = {
		is_enabled_animation: true,
		animation_time: 300,
		sound_volume: 100,
		is_enables_sound: true,
		is_overlay: true,
		is_change_mute: true,
		video_size: {
			main: {
				width: 1280,
				height: 720
			},
			sub: {
				ratio: 3,
				width: 426,
				height: 240
			}
		},
		url_1: '',
		url_2: '',
		title_1: '',
		title_2: ''
	};
	window.player = {
		'video-1': null,
		'video-2': null
	};
	window.seekSec = 0;
	window.timeoutId = null;
	$('#change-button').on('click', function () {
		var class_main = 'video-main';
		var class_sub = 'video-sub';
		var $main = $('.' + class_main);
		var $sub = $('.' + class_sub);
		$main.removeClass(class_main);
		$main.addClass(class_sub);
		set_video_size_sub($main);
		if (player[$main.attr('id')] && g.is_change_mute) {
			player[$main.attr('id')].mute();
		}
		$sub.removeClass(class_sub);
		$sub.addClass(class_main);
		set_video_size_main($sub);
		if (player[$sub.attr('id')] && g.is_change_mute) {
			player[$sub.attr('id')].unMute();
		}
		if (g.is_enabled_sound) sound.play(0, {
			volume: g.sound_volume / 100
		});
		$('.video-title').text($sub.attr('title'));
	});
	$('#is-change-mute-check').on('change', function () {
		g.is_change_mute = $(this).prop('checked');
		save();
	});
	$('#is-overlay-check').on('change', function () {
		g.is_overlay = $(this).prop('checked');
		$('#video-size-ok-button').trigger('click');
		save();
	});
	$('#is-enabled-sound-check').on('change', function () {
		g.is_enabled_sound = $(this).prop('checked');
		save();
	});
	$('#is-enabled-animation-check').on('change', function () {
		g.is_enabled_animation = $(this).prop('checked');
		var $video = $('.video');
		if ($video.size() > 0) {
			if (g.is_enabled_animation) {
				$video.css('transition', 'transform ' + g.animation_time + 'ms ease');
			} else {
				$video.css('transition', 'none');
			}
		}
		save();
	});
	$('.sound-volume-input').on('change', function () {
		var $this = $(this);
		if (this.timer_id) clearTimeout(this.timer_id);
		this.timer_id = setTimeout(function () {
			var num = parseInt($this.val());
			if (!isNaN(num)) {
				g.sound_volume = num;
				save();
			}
		}, 200);
	});
	$('.animation-time-input').on('change', function () {
		var $this = $(this);
		if (this.timer_id) clearTimeout(this.timer_id);
		this.timer_id = setTimeout(function () {
			var num = parseInt($this.val());
			if (!isNaN(num)) {
				g.animation_time = num;
				$('#is-enabled-animation-check').trigger('change');
				save();
			}
		}, 200);
	});
	$('#video-size-ok-button').on('click', function () {
		g.video_size.main.width = parseInt($('.video-width-input').val()) || 1280;
		g.video_size.main.height = parseInt($('.video-height-input').val()) || 720;
		g.video_size.sub.ratio = parseInt($('.video-ratio-input').val()) || 3;
		g.video_size.sub.width = Math.floor(g.video_size.main.width / g.video_size.sub.ratio);
		g.video_size.sub.height = Math.floor(g.video_size.main.height / g.video_size.sub.ratio);
		add_css();
		var class_main = 'video-main';
		var class_sub = 'video-sub';
		var $main = $('.video-main');
		var $sub = $('.video-sub');
		$main.removeClass('overlay');
		$sub.removeClass('overlay');
		if (g.is_overlay) {
			$main.addClass('overlay');
			$sub.addClass('overlay');
		}
		set_video_size_main($main);
		set_video_size_sub($sub);
		save();
	});
	$('#url-ok-button').on('click', function () {
		$('.video-wrapper').empty();
		$('<div></div>').attr('id', 'video-1').appendTo('.video-wrapper');
		$('<div></div>').attr('id', 'video-2').appendTo('.video-wrapper');
		player['video-1'] = null;
		player['video-2'] = null;
		g.url_1 = $('.url-input-1').val();
		g.url_2 = $('.url-input-2').val();
		g.title_1 = $('.title-input-1').val();
		g.title_2 = $('.title-input-2').val();
		g.video_size.main.width = parseInt($('.video-width-input').val()) || 1280;
		g.video_size.main.height = parseInt($('.video-height-input').val()) || 720;
		g.video_size.sub.ratio = parseInt($('.video-ratio-input').val()) || 3;
		g.video_size.sub.width = Math.floor(g.video_size.main.width / g.video_size.sub.ratio);
		g.video_size.sub.height = Math.floor(g.video_size.main.height / g.video_size.sub.ratio);
		add_css();
		var video_id_1 = get_video_id(g.url_1);
		var video_id_2 = get_video_id(g.url_2);
		if (video_id_1) {
			player['video-1'] = create_iframe(video_id_1, 'video-1', function ($video) {
				$video.addClass('video-main video video-1');
				$video.css({
					width: g.video_size.main.width + 'px',
					height: g.video_size.main.height + 'px'
				});
				if (g.is_enabled_animation) {
					$video.css('transition', 'transform ' + g.animation_time + 'ms ease');
				} else {
					$video.css('transition', 'none');
				}
				$video.attr('title', g.title_1);
				if (g.is_overlay) {
					$video.addClass('overlay');
				}
				set_video_size_main($video);
				
				$('.video-title').text(g.title_1)
			});
		}
		if (video_id_2) {
			player['video-2'] = create_iframe(video_id_2, 'video-2', function ($video) {
				$video.addClass('video-sub video video-2');
				$video.css({
					width: g.video_size.main.width + 'px',
					height: g.video_size.main.height + 'px'
				});
				if (g.is_enabled_animation) {
					$video.css('transition', 'transform ' + g.animation_time + 'ms ease');
				} else {
					$video.css('transition', 'none');
				}
				$video.attr('title', g.title_2);
				if (g.is_overlay) {
					$video.addClass('overlay');
				}
				set_video_size_sub($video);
			});
		}
		$('.control-button').attr('disabled', !(video_id_1 || video_id_2));
		save();
	});
	$('#button-play').on('click', function () {
		for (const player of Object.values(window.player)) {
			if (player) {
				player.playVideo();
			}
		}
	});
	$('#button-pause').on('click', function () {
		for (const player of Object.values(window.player)) {
			if (player) {
				player.pauseVideo();
			}
		}
	});
	$('#button-sf-5s').on('click', function () {
		handleSeek(5);
	});
	$('#button-sf-10s').on('click', function () {
		handleSeek(10);
	});
	$('#button-sb-5s').on('click', function () {
		handleSeek(-5);
	});
	$('#button-sb-10s').on('click', function () {
		handleSeek(-10);
	});
	load();
	console.log('html is ready!');
};
function add_css () {
	$('.add-style').remove();
	var $head = $('head').eq(0);
	var css_str = '<style class="add-style">'
	+'.video-main {'
	+'transform: ' + create_transform(0, 0, 1)
	/*
	+'width: ' + g.video_size.main.width + 'px;'
	+'height: ' + g.video_size.main.height + 'px;'
	+'left: ' + 0 + 'px;'
	+'top: ' + 0 + 'px;'
	*/
	+'} '
	+'.video-sub.overlay {'
	+'transform: ' + create_transform(0, 0, 1/g.video_size.sub.ratio)
	/*
	+'width: ' + g.video_size.sub.width + 'px;'
	+'height: ' + g.video_size.sub.height + 'px;'
	+'left: ' + (g.video_size.main.width - g.video_size.sub.width) + 'px;'
	+'top: ' + (g.video_size.main.height - g.video_size.sub.height) + 'px;'
	*/
	+'} '
	+'.video-sub {'
	+'transform: ' + create_transform(g.video_size.sub.width, 0, 1/g.video_size.sub.ratio)
	/*
	+'width: ' + g.video_size.sub.width + 'px;'
	+'height: ' + g.video_size.sub.height + 'px;'
	+'left: ' + g.video_size.main.width + 'px;'
	+'top: ' + (g.video_size.main.height - g.video_size.sub.height) + 'px;'
	*/
	+'} '
	+'</style>'
	var $css = $(css_str);
	$head.append($css);
	function create_transform (x, y, s) {
		return ''
		+ 'translateX(' + x + 'px) '
		+ 'translateY(' + y + 'px) '
		+ 'scale(' + s + ');'
	}
}
function save () {
	localStorage.setItem(storage_key, JSON.stringify(window.g));
	console.log('saved!');
}
function load () {
	var g_str = localStorage.getItem(storage_key);
	if (g_str) {
		$.extend(true, window.g, JSON.parse(g_str));
	}
	$('.url-input-1').val(g.url_1);
	$('.url-input-2').val(g.url_2);
	$('.title-input-1').val(g.title_1);
	$('.title-input-2').val(g.title_2);
	$('.video-width-input').val(g.video_size.main.width);
	$('.video-height-input').val(g.video_size.main.height);
	$('.video-ratio-input').val(g.video_size.sub.ratio);
	$('.sound-volume-input').val(g.sound_volume);
	$('.animation-time-input').val(g.animation_time);
	$('#is-change-mute-check').prop('checked', g.is_change_mute);
	$('#is-overlay-check').prop('checked', g.is_overlay);
	$('#is-enabled-sound-check').prop('checked', g.is_enabled_sound);
	$('#is-enabled-animation-check').prop('checked', g.is_enabled_animation).trigger('change');
	console.log('loaded!');
}
function set_video_size_main ($video) {
	$('.video-title').css('width', g.video_size.main.width + 'px');
	$('.video-area').css('height', g.video_size.main.height + 'px');
	/*
	$video.css({
		width: g.video_size.main.width + 'px',
		height: g.video_size.main.height + 'px',
		left: '0',
		top: '0'
	});
	*/
}
function set_video_size_sub ($video) {
	/*
	if (g.is_overlay) {
		$video.css({
			width: g.video_size.sub.width + 'px',
			height: g.video_size.sub.height + 'px',
			left: (g.video_size.main.width - g.video_size.sub.width) + 'px',
			top: (g.video_size.main.height - g.video_size.sub.height) + 'px'
		});
	} else {
		$video.css({
			width: g.video_size.sub.width + 'px',
			height: g.video_size.sub.height + 'px',
			left: (g.video_size.main.width) + 'px',
			top: (g.video_size.main.height - g.video_size.sub.height) + 'px'
		});
	}
	*/
}
function get_video_id (url) {
	var video_id = false;
	if (typeof url !== 'string') return false;
	if (url.indexOf('youtu.be/') > -1) {
		var arr = url.split('/');
		var last_url = arr.pop();
		return last_url.split('?')[0];
	}
	else if (url.indexOf('youtube.com/') > -1) {
		var arr = url.split('/');
		var last_url = arr.pop();
		var params_str = last_url.split('?')[1];
		var params = params_str.split('&');
		for (var i = 0; i < params.length; i++) {
			var param = params[i].split('=');
			var name = param[0];
			var value = param[1];
			if (name === 'v') video_id = value;
		}
		return video_id;
	}
	return video_id;
}
function create_iframe (video_id, div_id, call_back) {
	return new YT.Player(div_id, {
		width: g.video_size.main.width,
		height: g.video_size.main.height,
		videoId: video_id,
		events: {
			'onReady': function () {
				call_back($('#' + div_id));
			},
			'onStateChange': function (e) {
				// console.log(div_id, e.data);
				// 一方の動画再生が終了したらもう一方も一時停止する
				if (e.data === YT.PlayerState.ENDED) {
					$('#button-pause').trigger('click');
				}
			}
		},
		playerVars: {
		   "rel": 0,
		   "showinfo": 0,
		   "controls": 1
		}
	});
}
function sleep(ms) {
	return new Promise((resolve, reject) => {
		setTimeout(resolve, ms);
	});
}

/**
 * シークボタン押下時のハンドラ。連続押下に対応。
 * @param {Number} seekAmount 前に進めるときは正、後ろに戻すときは負の秒数を指定
 */
function handleSeek(seekAmount) {
	// すでに連続でシークボタンが押されている場合に予約済みのシーク処理をキャンセル
	if (timeoutId) {
		clearTimeout(timeoutId);
	}
	window.seekSec = window.seekSec + seekAmount;

	$('#seek-message').text(getSeekMessage());
	window.timeoutId = setTimeout(seekVideos, 1000); // TODO: 1000 -> 300
}
/**
 * シークボタンの横に表示するテキストメッセージを生成して返す。
 * @returns {String} シークする秒数と方向を示すメッセージ
 */
 function getSeekMessage() {
	if (window.seekSec > 0) {
		return `${window.seekSec}秒 >>`;
	} else if (window.seekSec < 0) {
		return `<< ${- window.seekSec}秒`;
	} else {
		return '';
	}
}
/**
 * すべての動画を再生位置の同期を保ちながらシークする。
 * <code>window.seekSec</code>の値をもとにシークする秒数を決定する。
 * 両方のバッファリングが完了するまで待機する(再生位置の同期を保つ)。
 */
 function seekVideos() {
	if (window.seekSec !== 0) {
		$('.control-button').attr('disabled', true);

		// 操作対象となるプレイヤーオブジェクトの配列（空(null)のプレイヤーはフィルタ）
		const targetPlayers = Object.values(window.player).filter((item) => !!item);
		// 各動画の始端／終端を考慮したシーク量を計算
		const seekAdjusted = calculateSeekAdjusted(targetPlayers, window.seekSec);

		// 各動画のシーク処理（非同期処理）
		const resultPromises = [];
		for (let i = 0; i < targetPlayers.length; i++) {
			resultPromises[i] = seekVideo(targetPlayers[i], seekAdjusted);
		}
		// すべてのバッファリングが完了するのを待って再生
		Promise.all(resultPromises).then((values) => {
			for (let i = 0; i < targetPlayers.length; i++) {
				// もともと一時停止だった場合は再生しない
				if (values[i].beforeState !== YT.PlayerState.PAUSED) {
					targetPlayers[i].playVideo();
				}
			}
		}).catch((err) => {
			console.log(err);
		});
	}

	// リセット
	window.seekSec = 0;
	window.timeoutId = null;
	$('#seek-message').text(getSeekMessage());
	$('.control-button').attr('disabled', false);
}
/**
 * 各動画の始端／終端を考慮したシーク量を計算する関数。
 * <code>window.seekSec</code>の値、および各動画の現在位置を元にシークする秒数を決定する。
 * @param {Array} players 計算対象のYTPlayerオブジェクトの配列。null値を含めないこと
 * @param {Number} seekSec 指定されたシーク秒数。前に進めるときは正、後ろに戻すときは負
 * @returns {Number} 各動画の始端／終端を考慮したシーク量。前に進めるときは正、後ろに戻すときは負の秒数
 */
 function calculateSeekAdjusted(players, seekSec) {
	const seekCandidates = [seekSec, ]; // シーク秒数の候補

	if (seekSec > 0) {
		// 指定したシーク秒数および各動画残り時間のうち最小値をシーク量とする
		seekCandidates.push(...players.map((p) => p.getDuration() - p.getCurrentTime()));
		return Math.min(...seekCandidates);
	} else if (seekSec < 0) {
		// 指定したシーク秒数および各動画経過時間のうち最小値をシーク量とする（負数なので計算には注意）
		seekCandidates.push(...players.map((p) => -p.getCurrentTime()));
		return Math.max(...seekCandidates);
	} else {
		return 0;
	}
}
/**
 * 指定したプレイヤーをシークし、バッファリング完了を待って一時停止する。
 * @param {YT.Player} player シーク対象のプレイヤーオブジェクト
 * @param {Number} seekSec 前に進めるときは正、後ろに戻すときは負の秒数を指定
 * @returns {Promise} 処理結果を返すPromiseオブジェクト
 * @returns {Object.Number} beforeState シーク操作前のプレイヤー状態
 * @returns {Object.Object} result YT.Player.seekTo()の実行結果
 */
function seekVideo(player, seekSec) {
	return new Promise((resolve, reject) => {
		const beforeState = player.getPlayerState();

		player.playVideo(); // バッファリング状態の変化を検知するために、一時停止中の動画も再生
		const result = player.seekTo(player.getCurrentTime() + seekSec, true);
		console.log(player.i, player.getPlayerState());

		// FIXME: シークした瞬間にBUFFERINGにならないらしく、意図した動作になっていない
		// シーク→イベントリスナ追加（BUFFERING検知したらコールバック（BUFFERING完了まで待ってイベントリスナ削除）実行）
		// BUFFERINGになるまで待つ

		while (true) {
			if (player.getPlayerState() !== YT.PlayerState.BUFFERING) {
				player.pauseVideo(); // 再生タイミングの同期を取りたいので一時停止
				resolve({
					beforeState: beforeState,
					result: result,
				});
				break;
			}
		}
		// });
	});
}
</script>
<style>
body {
    background: #222;
    color: #FFF;
    margin: 0;
}
.video-area {
	background: #000;
	position: relative;
	width: 100%;
	height: 720px;
	margin-top: 20px;
	margin-bottom: 40px;
}
	.video-title {
		position: absolute;
		top: -10px;
		left: 0px;
		width: 1280px;
		font-weight: bold;
		text-align: center;
		z-index: 102;
		text-shadow: 0px 0px 8px #000;
	}
	.video-wrapper {
		position: absolute;
		top: 0;
		left: 0;
	}
		.video {
			transition: transform .3s ease;
			transform-origin: right bottom;
		}
		.video-main {
			position: absolute;
			top: 0;
			left: 0;
			z-index: 100;
		}
		.video-sub {
			position: absolute;
			top: 0;
			left: 0;
			z-index: 101;
		}
.button-wrapper {
	left: 0px;
	top: 0px;
}
	.control-button {
		height: 30px;
	}
	#change-button {
		width: 200px;
		height: 50px;
	}
	.number-input {
		width: 40px;
	}
	.url-input {
		width: 440px;
	}
	#seek-message {
		/* TODO: リニアなアニメーションを付けたい */
		color: red;
	}
</style>
</head>
<body>
<h2>YouTube専用2窓実況支援ツール  Ver.1.0.1</h2>
<div class="button-wrapper">
	<p>URL1 <input class="url-input url-input-1" type="text" val="" placeholder="https://www.youtube.com/watch?v=... OR https://youtu.be/..."> TITLE1 <input class="title-input title-input-1" type="text" val="" placeholder="Aさん視点"></p>
	<p>URL2 <input class="url-input url-input-2" type="text" val="" placeholder="https://www.youtube.com/watch?v=... OR https://youtu.be/..."> TITLE2 <input class="title-input title-input-2" type="text" val="" placeholder="Bさん視点"> <button id="url-ok-button">URLとTITLEを決定して動画を見る</button></p>
	<p>メイン画面の幅 <input class="video-width-input number-input" type="text" > 高さ <input class="video-height-input number-input" type="text" > サブ画面の比率 <input class="video-ratio-input number-input" type="text" > 分の1 <button id="video-size-ok-button">画面設定を反映する</button>
	<p><label for="is-overlay-check">
	<input id="is-overlay-check" type="checkbox"> サブ画面をメイン画面の上に重ねる
	</label></p>
	<p><label for="is-change-mute-check">
	<input id="is-change-mute-check" type="checkbox"> 視点入れ替え時にサブ画面をミュートにしメイン画面をミュート解除する
	</label></p>
	<p><label for="is-enabled-sound-check">
	<input id="is-enabled-sound-check" type="checkbox"> 視点入れ替え時に効果音を鳴らす 音量 <input class="sound-volume-input number-input" type="text" > ％
	</label></p>
	<p><label for="is-enabled-animation-check">
	<input id="is-enabled-animation-check" type="checkbox"> 視点入れ替え時にアニメーションする 時間 <input class="animation-time-input number-input" type="text" > ミリ秒
	</label></p>
	<button class="control-button" id="change-button" disabled>視点入れ替え</button>
	<button class="control-button" id="button-sb-10s" disabled>10秒&#x23ea;</button>
	<button class="control-button" id="button-sb-5s" disabled>5秒&#x23ea;</button>
	<button class="control-button" id="button-play" disabled>再生&#x25b6;</button>
	<button class="control-button" id="button-pause" disabled>一時停止&#x23f8;</button>
	<button class="control-button" id="button-sf-5s" disabled>5秒&#x23e9;</button>
	<button class="control-button" id="button-sf-10s" disabled>10秒&#x23e9;</button>
	<span id="seek-message"></span>
</div>
<div class="video-area">
	<h2 class="video-title"></h2>
	<div class="video-wrapper">
		<div id="video-1"></div>
		<div id="video-2"></div>
		<!--
		<iframe title="高床さん" class="video video-1 video-main" width="1280" height="720" src="https://www.youtube.com/embed/EDGiz53SVWs"   frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
		<iframe title="シアロアさん" class="video video-2 video-sub"  width="1280" height="720" src="https://www.youtube.com/embed/zunGo8kXQlg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
		-->
	</div>
</div>
</body>
</html>